/**
 * SQL Generation Utilities
 *
 * This module provides database-agnostic SQL generation for schema migrations.
 * It handles differences between PostgreSQL, MySQL/MariaDB, and SQLite.
 */

import type {
    DatabaseEngine,
    ColumnInfo,
    IndexInfo,
    ForeignKeyInfo,
    TableSchema,
} from '@dbnexus/shared';

// ============ Identifier Quoting ============

/**
 * Quote an identifier based on database engine
 */
export function quoteIdentifier(name: string, engine: DatabaseEngine): string {
    if (engine === 'mysql' || engine === 'mariadb') {
        return `\`${name}\``;
    }
    return `"${name}"`;
}

/**
 * Quote a fully qualified table name (schema.table)
 */
export function quoteTable(schema: string, table: string, engine: DatabaseEngine): string {
    if (engine === 'sqlite') {
        return quoteIdentifier(table, engine);
    }
    return `${quoteIdentifier(schema, engine)}.${quoteIdentifier(table, engine)}`;
}

// ============ Array Parsing ============

/**
 * Parse a column array that might be a PostgreSQL array string or a JS array
 * PostgreSQL array format: "{col1,col2}" or just a regular JS array
 */
export function parseColumnArray(columns: string[] | string | undefined | null): string[] {
    if (!columns) return [];
    if (Array.isArray(columns)) return columns;
    if (typeof columns === 'string') {
        // PostgreSQL array format: "{col1,col2}"
        return columns.replaceAll(/[{}]/g, '').split(',').filter(Boolean);
    }
    return [];
}

// ============ Default Value Utilities ============

/**
 * Check if a default value is an identity/serial expression that cannot be altered via SET DEFAULT
 * These include: GENERATED ALWAYS/BY DEFAULT AS IDENTITY, nextval(), serial types
 */
export function isIdentityOrSerialDefault(defaultValue: string | null): boolean {
    if (!defaultValue) return false;
    const lower = defaultValue.toLowerCase();
    return (
        (lower.includes('generated') && lower.includes('identity')) ||
        lower.includes('nextval(') ||
        lower.includes('serial')
    );
}

/**
 * Normalize default values for comparison - some defaults are functionally equivalent
 * e.g., now() vs CURRENT_TIMESTAMP, different sequence naming conventions
 */
export function normalizeDefaultForComparison(defaultValue: string | null): string | null {
    if (!defaultValue) return null;
    const lower = defaultValue.toLowerCase().trim();

    // Normalize timestamp defaults
    if (lower === 'now()' || lower === 'current_timestamp' || lower === 'current_timestamp()') {
        return 'NOW()';
    }

    // Identity columns and sequences are functionally equivalent (auto-increment)
    // Normalize all forms: GENERATED ALWAYS AS IDENTITY, GENERATED BY DEFAULT AS IDENTITY,
    // nextval('sequence'), SERIAL types - all to the same value
    if (isIdentityOrSerialDefault(defaultValue)) {
        return 'AUTO_INCREMENT';
    }

    return defaultValue;
}

// ============ SQL Generators ============

/**
 * Generate CREATE TABLE SQL
 */
export function generateCreateTableSql(table: TableSchema, engine: DatabaseEngine): string[] {
    const sql: string[] = [];
    const columnDefs: string[] = [];

    for (const col of table.columns) {
        let def = `${quoteIdentifier(col.name, engine)} ${col.dataType}`;
        if (!col.nullable) def += ' NOT NULL';
        if (col.defaultValue !== null) def += ` DEFAULT ${col.defaultValue}`;
        columnDefs.push(def);
    }

    // Add primary key constraint
    const primaryKey = parseColumnArray(table.primaryKey);
    if (primaryKey.length > 0) {
        columnDefs.push(
            `PRIMARY KEY (${primaryKey.map((c) => quoteIdentifier(c, engine)).join(', ')})`
        );
    }

    sql.push(
        `CREATE TABLE ${quoteTable(table.schema, table.name, engine)} (\n  ${columnDefs.join(',\n  ')}\n);`
    );

    // Add indexes (excluding primary key)
    for (const idx of table.indexes) {
        if (!idx.isPrimary) {
            sql.push(generateCreateIndexSql(table.schema, table.name, idx, engine));
        }
    }

    // Add foreign keys
    for (const fk of table.foreignKeys) {
        sql.push(generateAddForeignKeySql(table.schema, table.name, fk, engine));
    }

    return sql;
}

/**
 * Generate DROP TABLE SQL
 */
export function generateDropTableSql(
    schema: string,
    table: string,
    engine: DatabaseEngine
): string {
    return `DROP TABLE IF EXISTS ${quoteTable(schema, table, engine)};`;
}

/**
 * Generate ADD COLUMN SQL
 */
export function generateAddColumnSql(
    schema: string,
    table: string,
    col: ColumnInfo,
    engine: DatabaseEngine
): string {
    let sql = `ALTER TABLE ${quoteTable(schema, table, engine)} ADD COLUMN ${quoteIdentifier(col.name, engine)} ${col.dataType}`;
    if (!col.nullable) sql += ' NOT NULL';
    if (col.defaultValue !== null) sql += ` DEFAULT ${col.defaultValue}`;
    return sql + ';';
}

/**
 * Generate DROP COLUMN SQL
 */
export function generateDropColumnSql(
    schema: string,
    table: string,
    columnName: string,
    engine: DatabaseEngine
): string {
    return `ALTER TABLE ${quoteTable(schema, table, engine)} DROP COLUMN ${quoteIdentifier(columnName, engine)};`;
}

/**
 * Generate ALTER COLUMN SQL for modifications
 * Returns an array of SQL statements needed to transform the column
 */
export function generateAlterColumnSql(
    schema: string,
    table: string,
    source: ColumnInfo,
    target: ColumnInfo,
    engine: DatabaseEngine
): string[] {
    const sql: string[] = [];
    const prefix = `ALTER TABLE ${quoteTable(schema, table, engine)}`;

    // Type change
    if (source.dataType.toLowerCase() !== target.dataType.toLowerCase()) {
        sql.push(...generateAlterColumnTypeSql(schema, table, source, engine));
    }

    // Nullable change
    if (source.nullable !== target.nullable) {
        sql.push(...generateAlterColumnNullableSql(schema, table, source, engine));
    }

    // Default change
    const sourceDefaultNorm = normalizeDefaultForComparison(source.defaultValue);
    const targetDefaultNorm = normalizeDefaultForComparison(target.defaultValue);

    if (sourceDefaultNorm !== targetDefaultNorm) {
        sql.push(...generateAlterColumnDefaultSql(prefix, source, target, engine));
    }

    return sql;
}

/**
 * Generate SQL to change column type
 */
function generateAlterColumnTypeSql(
    schema: string,
    table: string,
    source: ColumnInfo,
    engine: DatabaseEngine
): string[] {
    const prefix = `ALTER TABLE ${quoteTable(schema, table, engine)}`;

    if (engine === 'postgres') {
        return [
            `${prefix} ALTER COLUMN ${quoteIdentifier(source.name, engine)} TYPE ${source.dataType} USING ${quoteIdentifier(source.name, engine)}::${source.dataType};`,
        ];
    } else if (engine === 'mysql' || engine === 'mariadb') {
        let colDef = `${quoteIdentifier(source.name, engine)} ${source.dataType}`;
        if (!source.nullable) colDef += ' NOT NULL';
        if (source.defaultValue !== null) colDef += ` DEFAULT ${source.defaultValue}`;
        return [`${prefix} MODIFY COLUMN ${colDef};`];
    } else {
        return [
            `-- SQLite: Cannot alter column type. Manual migration required for "${source.name}"`,
        ];
    }
}

/**
 * Generate SQL to change column nullability
 */
function generateAlterColumnNullableSql(
    schema: string,
    table: string,
    source: ColumnInfo,
    engine: DatabaseEngine
): string[] {
    const prefix = `ALTER TABLE ${quoteTable(schema, table, engine)}`;

    if (engine === 'postgres') {
        if (source.nullable) {
            return [
                `${prefix} ALTER COLUMN ${quoteIdentifier(source.name, engine)} DROP NOT NULL;`,
            ];
        } else {
            return [`${prefix} ALTER COLUMN ${quoteIdentifier(source.name, engine)} SET NOT NULL;`];
        }
    } else if (engine === 'mysql' || engine === 'mariadb') {
        let colDef = `${quoteIdentifier(source.name, engine)} ${source.dataType}`;
        if (!source.nullable) colDef += ' NOT NULL';
        if (source.defaultValue !== null) colDef += ` DEFAULT ${source.defaultValue}`;
        return [`${prefix} MODIFY COLUMN ${colDef};`];
    } else {
        return [
            `-- SQLite: Cannot alter column nullability. Manual migration required for "${source.name}"`,
        ];
    }
}

/**
 * Generate SQL to change column default value
 */
function generateAlterColumnDefaultSql(
    prefix: string,
    source: ColumnInfo,
    target: ColumnInfo,
    engine: DatabaseEngine
): string[] {
    const sourceIsAutoInc = isIdentityOrSerialDefault(source.defaultValue);
    const targetIsAutoInc = isIdentityOrSerialDefault(target.defaultValue);

    // Both are auto-increment types but different syntax - no migration needed
    if (sourceIsAutoInc && targetIsAutoInc) {
        return [];
    }

    // One is auto-increment, the other is not - requires manual intervention
    if (sourceIsAutoInc || targetIsAutoInc) {
        return [
            `-- Cannot alter identity/serial column "${source.name}" via SET DEFAULT. Manual migration may be required.`,
        ];
    }

    if (engine === 'postgres' || engine === 'mysql' || engine === 'mariadb') {
        if (source.defaultValue === null) {
            return [`${prefix} ALTER COLUMN ${quoteIdentifier(source.name, engine)} DROP DEFAULT;`];
        } else {
            return [
                `${prefix} ALTER COLUMN ${quoteIdentifier(source.name, engine)} SET DEFAULT ${source.defaultValue};`,
            ];
        }
    } else {
        return [
            `-- SQLite: Cannot alter column default. Manual migration required for "${source.name}"`,
        ];
    }
}

/**
 * Generate CREATE INDEX SQL
 */
export function generateCreateIndexSql(
    schema: string,
    table: string,
    idx: IndexInfo,
    engine: DatabaseEngine
): string {
    const unique = idx.isUnique ? 'UNIQUE ' : '';
    const idxColumns = parseColumnArray(idx.columns);
    const columns = idxColumns.map((c) => quoteIdentifier(c, engine)).join(', ');
    return `CREATE ${unique}INDEX ${quoteIdentifier(idx.name, engine)} ON ${quoteTable(schema, table, engine)} (${columns});`;
}

/**
 * Generate DROP INDEX SQL
 */
export function generateDropIndexSql(
    schema: string,
    table: string,
    indexName: string,
    engine: DatabaseEngine
): string {
    if (engine === 'mysql' || engine === 'mariadb') {
        return `DROP INDEX ${quoteIdentifier(indexName, engine)} ON ${quoteTable(schema, table, engine)};`;
    }
    return `DROP INDEX IF EXISTS ${quoteIdentifier(schema, engine)}.${quoteIdentifier(indexName, engine)};`;
}

/**
 * Generate ADD FOREIGN KEY SQL
 */
export function generateAddForeignKeySql(
    schema: string,
    table: string,
    fk: ForeignKeyInfo,
    engine: DatabaseEngine
): string {
    const fkColumns = parseColumnArray(fk.columns);
    const fkRefColumns = parseColumnArray(fk.referencedColumns);
    const columns = fkColumns.map((c) => quoteIdentifier(c, engine)).join(', ');
    const refColumns = fkRefColumns.map((c) => quoteIdentifier(c, engine)).join(', ');

    return `ALTER TABLE ${quoteTable(schema, table, engine)} ADD CONSTRAINT ${quoteIdentifier(fk.name, engine)} FOREIGN KEY (${columns}) REFERENCES ${quoteTable(fk.referencedSchema, fk.referencedTable, engine)} (${refColumns}) ON DELETE ${fk.onDelete} ON UPDATE ${fk.onUpdate};`;
}

/**
 * Generate DROP FOREIGN KEY SQL
 */
export function generateDropForeignKeySql(
    schema: string,
    table: string,
    constraintName: string,
    engine: DatabaseEngine
): string {
    if (engine === 'mysql' || engine === 'mariadb') {
        return `ALTER TABLE ${quoteTable(schema, table, engine)} DROP FOREIGN KEY ${quoteIdentifier(constraintName, engine)};`;
    }
    return `ALTER TABLE ${quoteTable(schema, table, engine)} DROP CONSTRAINT ${quoteIdentifier(constraintName, engine)};`;
}

/**
 * Generate CREATE SCHEMA SQL
 */
export function generateCreateSchemaSql(schemaName: string, engine: DatabaseEngine): string {
    if (engine === 'mysql' || engine === 'mariadb') {
        return `CREATE DATABASE IF NOT EXISTS ${quoteIdentifier(schemaName, engine)};`;
    } else if (engine === 'postgres') {
        return `CREATE SCHEMA IF NOT EXISTS ${quoteIdentifier(schemaName, engine)};`;
    }
    // SQLite doesn't have schemas
    return `-- SQLite does not support schemas`;
}
